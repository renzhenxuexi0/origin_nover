// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.37.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value
)]

// Section: imports

use crate::api::parse_book_source::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0-dev.37";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -2039966169;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__parse_book_source__parse_book_source_from_url_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "parse_book_source_from_url",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_url = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse(
                    (move || async move {
                        crate::api::parse_book_source::parse_book_source_from_url(&api_url).await
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<reqwest::Error>
);

// Section: dart2rust

impl SseDecode for reqwest::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<reqwest::Error>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<reqwest::Error>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::model::book_source::BookSource {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_bookSourceComment = <Option<String>>::sse_decode(deserializer);
        let mut var_bookSourceGroup = <Option<String>>::sse_decode(deserializer);
        let mut var_bookSourceName = <Option<String>>::sse_decode(deserializer);
        let mut var_bookSourceType = <Option<i64>>::sse_decode(deserializer);
        let mut var_bookSourceUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_customOrder = <Option<i64>>::sse_decode(deserializer);
        let mut var_enabled = <Option<bool>>::sse_decode(deserializer);
        let mut var_enabledCookieJar = <Option<bool>>::sse_decode(deserializer);
        let mut var_enabledExplore = <Option<bool>>::sse_decode(deserializer);
        let mut var_exploreUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_lastUpdateTime = <Option<i64>>::sse_decode(deserializer);
        let mut var_respondTime = <Option<i64>>::sse_decode(deserializer);
        let mut var_ruleBookInfo =
            <Option<crate::api::model::book_source::RuleBookInfo>>::sse_decode(deserializer);
        let mut var_ruleContent =
            <Option<crate::api::model::book_source::RuleContent>>::sse_decode(deserializer);
        let mut var_ruleExplore =
            <Option<crate::api::model::book_source::RuleExplore>>::sse_decode(deserializer);
        let mut var_ruleReview =
            <Option<crate::api::model::book_source::RuleReview>>::sse_decode(deserializer);
        let mut var_ruleSearch =
            <Option<crate::api::model::book_source::RuleSearch>>::sse_decode(deserializer);
        let mut var_ruleToc =
            <Option<crate::api::model::book_source::RuleToc>>::sse_decode(deserializer);
        let mut var_searchUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_weight = <Option<i64>>::sse_decode(deserializer);
        return crate::api::model::book_source::BookSource {
            book_source_comment: var_bookSourceComment,
            book_source_group: var_bookSourceGroup,
            book_source_name: var_bookSourceName,
            book_source_type: var_bookSourceType,
            book_source_url: var_bookSourceUrl,
            custom_order: var_customOrder,
            enabled: var_enabled,
            enabled_cookie_jar: var_enabledCookieJar,
            enabled_explore: var_enabledExplore,
            explore_url: var_exploreUrl,
            last_update_time: var_lastUpdateTime,
            respond_time: var_respondTime,
            rule_book_info: var_ruleBookInfo,
            rule_content: var_ruleContent,
            rule_explore: var_ruleExplore,
            rule_review: var_ruleReview,
            rule_search: var_ruleSearch,
            rule_toc: var_ruleToc,
            search_url: var_searchUrl,
            weight: var_weight,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for Vec<crate::api::model::book_source::BookSource> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::model::book_source::BookSource>::sse_decode(
                deserializer,
            ));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::model::book_source::RuleBookInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::model::book_source::RuleBookInfo>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::model::book_source::RuleContent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::model::book_source::RuleContent>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::model::book_source::RuleExplore> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::model::book_source::RuleExplore>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::model::book_source::RuleReview> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::model::book_source::RuleReview>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::model::book_source::RuleSearch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::model::book_source::RuleSearch>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::model::book_source::RuleToc> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::model::book_source::RuleToc>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::model::book_source::RuleBookInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_author = <Option<String>>::sse_decode(deserializer);
        let mut var_coverUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_init = <Option<String>>::sse_decode(deserializer);
        let mut var_intro = <Option<String>>::sse_decode(deserializer);
        let mut var_kind = <Option<String>>::sse_decode(deserializer);
        let mut var_lastChapter = <Option<String>>::sse_decode(deserializer);
        let mut var_name = <Option<String>>::sse_decode(deserializer);
        let mut var_tocUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_wordCount = <Option<String>>::sse_decode(deserializer);
        let mut var_downloadUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_canReName = <Option<String>>::sse_decode(deserializer);
        return crate::api::model::book_source::RuleBookInfo {
            author: var_author,
            cover_url: var_coverUrl,
            init: var_init,
            intro: var_intro,
            kind: var_kind,
            last_chapter: var_lastChapter,
            name: var_name,
            toc_url: var_tocUrl,
            word_count: var_wordCount,
            download_url: var_downloadUrl,
            can_re_name: var_canReName,
        };
    }
}

impl SseDecode for crate::api::model::book_source::RuleContent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_content = <Option<String>>::sse_decode(deserializer);
        let mut var_replaceRegex = <Option<String>>::sse_decode(deserializer);
        let mut var_title = <Option<String>>::sse_decode(deserializer);
        let mut var_nextContentUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_webJs = <Option<String>>::sse_decode(deserializer);
        let mut var_sourceRegex = <Option<String>>::sse_decode(deserializer);
        let mut var_imageStyle = <Option<String>>::sse_decode(deserializer);
        let mut var_payAction = <Option<String>>::sse_decode(deserializer);
        return crate::api::model::book_source::RuleContent {
            content: var_content,
            replace_regex: var_replaceRegex,
            title: var_title,
            next_content_url: var_nextContentUrl,
            web_js: var_webJs,
            source_regex: var_sourceRegex,
            image_style: var_imageStyle,
            pay_action: var_payAction,
        };
    }
}

impl SseDecode for crate::api::model::book_source::RuleExplore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_author = <Option<String>>::sse_decode(deserializer);
        let mut var_bookList = <Option<String>>::sse_decode(deserializer);
        let mut var_bookUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_coverUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_lastChapter = <Option<String>>::sse_decode(deserializer);
        let mut var_intro = <Option<String>>::sse_decode(deserializer);
        let mut var_name = <Option<String>>::sse_decode(deserializer);
        let mut var_wordCount = <Option<String>>::sse_decode(deserializer);
        let mut var_kind = <Option<String>>::sse_decode(deserializer);
        return crate::api::model::book_source::RuleExplore {
            author: var_author,
            book_list: var_bookList,
            book_url: var_bookUrl,
            cover_url: var_coverUrl,
            last_chapter: var_lastChapter,
            intro: var_intro,
            name: var_name,
            word_count: var_wordCount,
            kind: var_kind,
        };
    }
}

impl SseDecode for crate::api::model::book_source::RuleReview {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_reviewUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_avatarRule = <Option<String>>::sse_decode(deserializer);
        let mut var_contentRule = <Option<String>>::sse_decode(deserializer);
        let mut var_postTimeRule = <Option<String>>::sse_decode(deserializer);
        let mut var_reviewQuoteUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_voteUpUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_voteDownUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_postReviewUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_postQuoteUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_deleteUrl = <Option<String>>::sse_decode(deserializer);
        return crate::api::model::book_source::RuleReview {
            review_url: var_reviewUrl,
            avatar_rule: var_avatarRule,
            content_rule: var_contentRule,
            post_time_rule: var_postTimeRule,
            review_quote_url: var_reviewQuoteUrl,
            vote_up_url: var_voteUpUrl,
            vote_down_url: var_voteDownUrl,
            post_review_url: var_postReviewUrl,
            post_quote_url: var_postQuoteUrl,
            delete_url: var_deleteUrl,
        };
    }
}

impl SseDecode for crate::api::model::book_source::RuleSearch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_author = <Option<String>>::sse_decode(deserializer);
        let mut var_bookList = <Option<String>>::sse_decode(deserializer);
        let mut var_bookUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_coverUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_intro = <Option<String>>::sse_decode(deserializer);
        let mut var_name = <Option<String>>::sse_decode(deserializer);
        let mut var_wordCount = <Option<String>>::sse_decode(deserializer);
        let mut var_kind = <Option<String>>::sse_decode(deserializer);
        return crate::api::model::book_source::RuleSearch {
            author: var_author,
            book_list: var_bookList,
            book_url: var_bookUrl,
            cover_url: var_coverUrl,
            intro: var_intro,
            name: var_name,
            word_count: var_wordCount,
            kind: var_kind,
        };
    }
}

impl SseDecode for crate::api::model::book_source::RuleToc {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_chapterList = <Option<String>>::sse_decode(deserializer);
        let mut var_chapterName = <Option<String>>::sse_decode(deserializer);
        let mut var_chapterUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_isVolume = <Option<String>>::sse_decode(deserializer);
        let mut var_preUpdateJson = <Option<String>>::sse_decode(deserializer);
        let mut var_formatJs = <Option<String>>::sse_decode(deserializer);
        let mut var_isVip = <Option<String>>::sse_decode(deserializer);
        let mut var_isPay = <Option<String>>::sse_decode(deserializer);
        let mut var_nextTocUrl = <Option<String>>::sse_decode(deserializer);
        let mut var_updateTime = <Option<String>>::sse_decode(deserializer);
        return crate::api::model::book_source::RuleToc {
            chapter_list: var_chapterList,
            chapter_name: var_chapterName,
            chapter_url: var_chapterUrl,
            is_volume: var_isVolume,
            pre_update_json: var_preUpdateJson,
            format_js: var_formatJs,
            is_vip: var_isVip,
            is_pay: var_isPay,
            next_toc_url: var_nextTocUrl,
            update_time: var_updateTime,
        };
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__parse_book_source__parse_book_source_from_url_impl(
            port,
            ptr,
            rust_vec_len,
            data_len,
        ),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<reqwest::Error> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<reqwest::Error> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<reqwest::Error>> for reqwest::Error {
    fn into_into_dart(self) -> FrbWrapper<reqwest::Error> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::model::book_source::BookSource {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.book_source_comment.into_into_dart().into_dart(),
            self.book_source_group.into_into_dart().into_dart(),
            self.book_source_name.into_into_dart().into_dart(),
            self.book_source_type.into_into_dart().into_dart(),
            self.book_source_url.into_into_dart().into_dart(),
            self.custom_order.into_into_dart().into_dart(),
            self.enabled.into_into_dart().into_dart(),
            self.enabled_cookie_jar.into_into_dart().into_dart(),
            self.enabled_explore.into_into_dart().into_dart(),
            self.explore_url.into_into_dart().into_dart(),
            self.last_update_time.into_into_dart().into_dart(),
            self.respond_time.into_into_dart().into_dart(),
            self.rule_book_info.into_into_dart().into_dart(),
            self.rule_content.into_into_dart().into_dart(),
            self.rule_explore.into_into_dart().into_dart(),
            self.rule_review.into_into_dart().into_dart(),
            self.rule_search.into_into_dart().into_dart(),
            self.rule_toc.into_into_dart().into_dart(),
            self.search_url.into_into_dart().into_dart(),
            self.weight.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::model::book_source::BookSource
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::model::book_source::BookSource>
    for crate::api::model::book_source::BookSource
{
    fn into_into_dart(self) -> crate::api::model::book_source::BookSource {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::model::book_source::RuleBookInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.author.into_into_dart().into_dart(),
            self.cover_url.into_into_dart().into_dart(),
            self.init.into_into_dart().into_dart(),
            self.intro.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.last_chapter.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.toc_url.into_into_dart().into_dart(),
            self.word_count.into_into_dart().into_dart(),
            self.download_url.into_into_dart().into_dart(),
            self.can_re_name.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::model::book_source::RuleBookInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::model::book_source::RuleBookInfo>
    for crate::api::model::book_source::RuleBookInfo
{
    fn into_into_dart(self) -> crate::api::model::book_source::RuleBookInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::model::book_source::RuleContent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.content.into_into_dart().into_dart(),
            self.replace_regex.into_into_dart().into_dart(),
            self.title.into_into_dart().into_dart(),
            self.next_content_url.into_into_dart().into_dart(),
            self.web_js.into_into_dart().into_dart(),
            self.source_regex.into_into_dart().into_dart(),
            self.image_style.into_into_dart().into_dart(),
            self.pay_action.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::model::book_source::RuleContent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::model::book_source::RuleContent>
    for crate::api::model::book_source::RuleContent
{
    fn into_into_dart(self) -> crate::api::model::book_source::RuleContent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::model::book_source::RuleExplore {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.author.into_into_dart().into_dart(),
            self.book_list.into_into_dart().into_dart(),
            self.book_url.into_into_dart().into_dart(),
            self.cover_url.into_into_dart().into_dart(),
            self.last_chapter.into_into_dart().into_dart(),
            self.intro.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.word_count.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::model::book_source::RuleExplore
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::model::book_source::RuleExplore>
    for crate::api::model::book_source::RuleExplore
{
    fn into_into_dart(self) -> crate::api::model::book_source::RuleExplore {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::model::book_source::RuleReview {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.review_url.into_into_dart().into_dart(),
            self.avatar_rule.into_into_dart().into_dart(),
            self.content_rule.into_into_dart().into_dart(),
            self.post_time_rule.into_into_dart().into_dart(),
            self.review_quote_url.into_into_dart().into_dart(),
            self.vote_up_url.into_into_dart().into_dart(),
            self.vote_down_url.into_into_dart().into_dart(),
            self.post_review_url.into_into_dart().into_dart(),
            self.post_quote_url.into_into_dart().into_dart(),
            self.delete_url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::model::book_source::RuleReview
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::model::book_source::RuleReview>
    for crate::api::model::book_source::RuleReview
{
    fn into_into_dart(self) -> crate::api::model::book_source::RuleReview {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::model::book_source::RuleSearch {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.author.into_into_dart().into_dart(),
            self.book_list.into_into_dart().into_dart(),
            self.book_url.into_into_dart().into_dart(),
            self.cover_url.into_into_dart().into_dart(),
            self.intro.into_into_dart().into_dart(),
            self.name.into_into_dart().into_dart(),
            self.word_count.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::model::book_source::RuleSearch
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::model::book_source::RuleSearch>
    for crate::api::model::book_source::RuleSearch
{
    fn into_into_dart(self) -> crate::api::model::book_source::RuleSearch {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::model::book_source::RuleToc {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.chapter_list.into_into_dart().into_dart(),
            self.chapter_name.into_into_dart().into_dart(),
            self.chapter_url.into_into_dart().into_dart(),
            self.is_volume.into_into_dart().into_dart(),
            self.pre_update_json.into_into_dart().into_dart(),
            self.format_js.into_into_dart().into_dart(),
            self.is_vip.into_into_dart().into_dart(),
            self.is_pay.into_into_dart().into_dart(),
            self.next_toc_url.into_into_dart().into_dart(),
            self.update_time.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::model::book_source::RuleToc
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::model::book_source::RuleToc>
    for crate::api::model::book_source::RuleToc
{
    fn into_into_dart(self) -> crate::api::model::book_source::RuleToc {
        self
    }
}

impl SseEncode for reqwest::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<reqwest :: Error>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<reqwest::Error>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::model::book_source::BookSource {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.book_source_comment, serializer);
        <Option<String>>::sse_encode(self.book_source_group, serializer);
        <Option<String>>::sse_encode(self.book_source_name, serializer);
        <Option<i64>>::sse_encode(self.book_source_type, serializer);
        <Option<String>>::sse_encode(self.book_source_url, serializer);
        <Option<i64>>::sse_encode(self.custom_order, serializer);
        <Option<bool>>::sse_encode(self.enabled, serializer);
        <Option<bool>>::sse_encode(self.enabled_cookie_jar, serializer);
        <Option<bool>>::sse_encode(self.enabled_explore, serializer);
        <Option<String>>::sse_encode(self.explore_url, serializer);
        <Option<i64>>::sse_encode(self.last_update_time, serializer);
        <Option<i64>>::sse_encode(self.respond_time, serializer);
        <Option<crate::api::model::book_source::RuleBookInfo>>::sse_encode(
            self.rule_book_info,
            serializer,
        );
        <Option<crate::api::model::book_source::RuleContent>>::sse_encode(
            self.rule_content,
            serializer,
        );
        <Option<crate::api::model::book_source::RuleExplore>>::sse_encode(
            self.rule_explore,
            serializer,
        );
        <Option<crate::api::model::book_source::RuleReview>>::sse_encode(
            self.rule_review,
            serializer,
        );
        <Option<crate::api::model::book_source::RuleSearch>>::sse_encode(
            self.rule_search,
            serializer,
        );
        <Option<crate::api::model::book_source::RuleToc>>::sse_encode(self.rule_toc, serializer);
        <Option<String>>::sse_encode(self.search_url, serializer);
        <Option<i64>>::sse_encode(self.weight, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for Vec<crate::api::model::book_source::BookSource> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::model::book_source::BookSource>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::model::book_source::RuleBookInfo> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::model::book_source::RuleBookInfo>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::model::book_source::RuleContent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::model::book_source::RuleContent>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::model::book_source::RuleExplore> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::model::book_source::RuleExplore>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::model::book_source::RuleReview> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::model::book_source::RuleReview>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::model::book_source::RuleSearch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::model::book_source::RuleSearch>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::model::book_source::RuleToc> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::model::book_source::RuleToc>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::model::book_source::RuleBookInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.author, serializer);
        <Option<String>>::sse_encode(self.cover_url, serializer);
        <Option<String>>::sse_encode(self.init, serializer);
        <Option<String>>::sse_encode(self.intro, serializer);
        <Option<String>>::sse_encode(self.kind, serializer);
        <Option<String>>::sse_encode(self.last_chapter, serializer);
        <Option<String>>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.toc_url, serializer);
        <Option<String>>::sse_encode(self.word_count, serializer);
        <Option<String>>::sse_encode(self.download_url, serializer);
        <Option<String>>::sse_encode(self.can_re_name, serializer);
    }
}

impl SseEncode for crate::api::model::book_source::RuleContent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.content, serializer);
        <Option<String>>::sse_encode(self.replace_regex, serializer);
        <Option<String>>::sse_encode(self.title, serializer);
        <Option<String>>::sse_encode(self.next_content_url, serializer);
        <Option<String>>::sse_encode(self.web_js, serializer);
        <Option<String>>::sse_encode(self.source_regex, serializer);
        <Option<String>>::sse_encode(self.image_style, serializer);
        <Option<String>>::sse_encode(self.pay_action, serializer);
    }
}

impl SseEncode for crate::api::model::book_source::RuleExplore {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.author, serializer);
        <Option<String>>::sse_encode(self.book_list, serializer);
        <Option<String>>::sse_encode(self.book_url, serializer);
        <Option<String>>::sse_encode(self.cover_url, serializer);
        <Option<String>>::sse_encode(self.last_chapter, serializer);
        <Option<String>>::sse_encode(self.intro, serializer);
        <Option<String>>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.word_count, serializer);
        <Option<String>>::sse_encode(self.kind, serializer);
    }
}

impl SseEncode for crate::api::model::book_source::RuleReview {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.review_url, serializer);
        <Option<String>>::sse_encode(self.avatar_rule, serializer);
        <Option<String>>::sse_encode(self.content_rule, serializer);
        <Option<String>>::sse_encode(self.post_time_rule, serializer);
        <Option<String>>::sse_encode(self.review_quote_url, serializer);
        <Option<String>>::sse_encode(self.vote_up_url, serializer);
        <Option<String>>::sse_encode(self.vote_down_url, serializer);
        <Option<String>>::sse_encode(self.post_review_url, serializer);
        <Option<String>>::sse_encode(self.post_quote_url, serializer);
        <Option<String>>::sse_encode(self.delete_url, serializer);
    }
}

impl SseEncode for crate::api::model::book_source::RuleSearch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.author, serializer);
        <Option<String>>::sse_encode(self.book_list, serializer);
        <Option<String>>::sse_encode(self.book_url, serializer);
        <Option<String>>::sse_encode(self.cover_url, serializer);
        <Option<String>>::sse_encode(self.intro, serializer);
        <Option<String>>::sse_encode(self.name, serializer);
        <Option<String>>::sse_encode(self.word_count, serializer);
        <Option<String>>::sse_encode(self.kind, serializer);
    }
}

impl SseEncode for crate::api::model::book_source::RuleToc {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.chapter_list, serializer);
        <Option<String>>::sse_encode(self.chapter_name, serializer);
        <Option<String>>::sse_encode(self.chapter_url, serializer);
        <Option<String>>::sse_encode(self.is_volume, serializer);
        <Option<String>>::sse_encode(self.pre_update_json, serializer);
        <Option<String>>::sse_encode(self.format_js, serializer);
        <Option<String>>::sse_encode(self.is_vip, serializer);
        <Option<String>>::sse_encode(self.is_pay, serializer);
        <Option<String>>::sse_encode(self.next_toc_url, serializer);
        <Option<String>>::sse_encode(self.update_time, serializer);
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "frb_generated.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;
